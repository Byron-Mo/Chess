exit
piece.valid_moves
piece
n
move
n
c
n
s
exit
piece.pos
piece
n
piece
n
attack_pieces.size
attack_pieces
n
piece.pos
piece
attack_pieces.size
attack_pieces
n
attack_pieces
n
attack_piece.pos
attack_piece
n
move
piece.pos
piece
exit
piece.valid_moves
end_pos
start_pos
piece.pos
piece.start_pos
exit
s
piece.valid_moves
piece.pos
piece
exit
end_pos
piece.valid_moves
start_pos
piece.pos
exit
end_pos
moves[rand(moves.length)]
moves = piece.valid_moves
end_pos
piece.valid_moves
piece.moves
n
start_pos
piece.pos
piece
end_pos
piece.end_pos
c
n
c
n
end_pos
c
n
end_pos
start_pos
piece
c
n
c
exit
c
n
s
n
select_piece.valid_moves
select_piece
exit
@board[row, col].color
@board[row, col].nil?
@board[row, col]
piece
s
exit
row
n
exit
locations
n
exit
n
@board[0, 0]
@board
exit
locations
n
exit
locations
locations[rand(locations.length)].pos
n
exit
n
piece.pos
n
exit
piece.pos
pieces[rand(pieces.length)].pos
pieces[rand(pieces.length)]
pieces
piece.pos
n
moveable_pieces
pieces
exit
n
exit
c
n
c
n
up
n
exit
@board.grid.flatten.select{|location| location.color == color}
@board.grid.flatten.select{|location| location.nil?}
locations
locations[rand(locations.length)].pos
n
piece.pos
piece
n
exit
c
n
@board
n
exit
n
moves
super
n
c
exit
c
n
moves
n
moves
n
moves
super
n
@adjacent_right.double_step
@adjacent_right.instance_of?(Pawn)
@adjacent_right.nil?
idx
n
idx
n
idx
c
@adjacent_left.nil? == false
@adjacent_left.nil?
@adjacent_left
c
self[0, 0]
self
@adjacent_left.instance_of?(Pawn)
@adjacent_right.instance_of?(Pawn)
@adjacent_right.double_step
@adjacent_right
@adjacent_left.double_step
@adjacent_left
c
pawn.double_step
self[*pos].double_step
self[*pos]
pawn.color
pawn
self[*pos]
pos
c
n
@adjacent_right
@adjacent_left
